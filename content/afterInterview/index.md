---
emoji: ✍️
title: 면접후기 매꾸기
date: '2021-12-16 18:00:00'
author: me
tags: 면접후기 질문기록
categories: 면접후기
---

# 면접 후기록 및 질문 리스트 재복습

지원을 한 회사들중 처음으로 면접을 보았습니다.
너무 긴장되어서 말을 횡설수설한거같은 느낌입니다.
차분하게 생각하면 떠오르는 부분들이 왜 그렇게 백지가 되는건지...

결과가 나오기 전까지 안절부절하는 마음을 부여잡고
우선 오늘 기술부분으로 질문을 받은 리스트를 이전보다 더 상세하게 정리하려합니다.

## 1. 호이스팅이란 무엇인가?

우선 호이스팅을 알기전 자바스크립트의 변수들을 알아보자

- var
- let
- const
  이렇게 3가지 형태의 변수가 존재한다.
  var는 중복으로 선언이 가능하다. 예를들어

```
var name = 'kimchi';
console.log(name) // kimchi
var name = 'dragon';
console.log(name) // dragon
```

이렇게 선언 후 다시 재 선언을 하여도 실행에 지장이없다.
하지만 let과 const는 재선언이 불가능하다.

```
let name = 'kim';
console.log(name) // kim
let name = 'lee' // error
// const 동일
```

이렇게 var를 제외하고는 변수들은 재선언이 불가능하다.

여기서 var를 예시로 호이스팅을 알수있다.
**var는 선언하기전에 사용이 가능하다.**
예를들어

```
console.log(name); // undefined
var name = 'kim';
```

이렇게 선언이 가능하며 에러가 나지않는다. 이는 사실 아래와 같이 동작하기 때문이다.

```
var name;
console.log(name); // undefined
var name = 'kim';
```

**위의 상태처럼 var는 사용 후 선언하여도 최상단에 이미 선언이 되어있다. 이를 우리는 호이스팅이라 부른다.**<br />
또다른 말로는 **스코프 내부 어디서든 변수 선언은 최상위에 선언된 것 처럼 행동하는것을 말한다.**

그렇다면 let과 const는 호이스팅이 되지않는걸까?
결론은 아니다.
호이스팅은 되지만 에러가 나는 이유는 TDZ(Temporal Dead Zone)떄문이다.

let과 const는 var와 다르게 TDZ존의 영향을 받는다.

```
------- // DTZ존 start // 이곳 안에 있는 변수들은 사용을 할수없다. 그래서 에러가 난다.
console.log(name); // 에러

------- // TDZ존 end
const name = 'kim'; // 선언 및 할당
console.log(name) // 사용가능
```

## 그래서 let과 const를 사용하여야 하는 이유는

이로서 코드를 예측가능하게 하고 잠재적인 버그를 잡을수 있다.
그렇기에 우리들은 let과 const를 사용하여야한다.

변수는 3단계의 생성과정을 거친다.

1. 선언 단계
2. 초기화 단계
3. 할당 단계

- var는 **선언과 초기화가 동시에 일어난 후 할당 단계를 거친다.**
- let은 **선언 -> 초기화 -> 할당**
- const는 **선언과 초기화와 할당이 동시에 진행된다.**

## null과 undefined의 차이

사실 너무 쉽게 생각했는데 전달을 이상하게 한것같다.
면접관분들에게 null은 값이 없는 형태,
undefined는 값이 있으나 비어있는 상태라는 답변을 했다.
면접을 마친 후 다시한번 바로알아보았는데
정의는 이렇다.

- undefined 은 변수를 선언하고 **값을 할당하지 않은 상태**
- null은 변수를 선언하고 **빈 값을 할당**한 상태

보고 난 후 아..싶었다.
내가 먼가 착각을 한거같다.
너무 창피해서 면접을 끝내고 집으로 오는길에 자책만 한거같다.하하...
다시는 기초적이고 바보같은 실수하지말도록 상기시켜야한다. 이불킥이다.

## 배열 메서드 정리

### 개인적으로 자주 쓴 메서드

- map : 배열의 각 원소별로 지정된 함수를 실행한 결과로 구성된 새로운 **배열을 반환**한다.
- reduce : 누산기(accumulator) 및 배열의 각 값(좌에서 우로)에 대해 (누산된) 한 값으로 줄도록 함수를 적용(잘쓰면 엄청 좋음)
- find : 특정 결과에 대하여 true인 데이터만 반환한다.
- filter : 지정된 함수의 결과 값을 true로 만드는 원소들로만 구성된 별도의 배열을 반환한다.
- splice : 배열의 특정위치에 요소를 추가하거나 삭제 // splice(index, 제거할 요소 개수, 배열에 추가될 요소)
- push : 배열 뒷부분에 값을 삽입
- forEach : 배열의 각 원소별로 지정된 함수를 실행한다. 하지만 리턴값을 반환하지는 않는다.

**배열함수는 아니지만 배열로 만들기 좋은 함수**

- split(매개체) : 매개체를 기준으로 여러개의 배열로 나눈다. 유용함

### 알고는 있지만 자주 활용하진 않았던 메서드

- pop : 배열 뒷부분의 값을 삭제
- unshift : 배열 앞부분에 값을 삽입
- shift : 배열 앞부분의 값을 삭제
- concat : 다수의 배열을 합치고 병합된 배열의 사본을 반환
- every : 배열의 모든 요소가 제공한 함수로 구현된 테스트를 통과하는지를 테스트
- some : 지정된 함수의 결과가 true일 때까지 배열의 각 원소를 반복
- reverse : 배열의 원소 순서를 거꾸로 바꾼다.
- sort : 배열의 원소를 알파벳순으로, 또는 지정된 함수에 따른 순서로 정렬한다. 모든 원소를 문자열로 취급해 사전적으로 정렬
- toString : 배열을 문자열로 바꾸어 반환한다
- valueOf : toString과 비슷, 그러나 배열을 반환
- join : 배열 원소 전부를 하나의 문자열로 합친다.

```
var arr =[ 1, 2, 3, 4 ];
console.log( arr.join() );      // 1,2,3,4
console.log( arr.join( '-' ) ); // 1-2-3-4

```

- slice : startIndex부터 endIndex까지에 대한 새로운 배열 반환 //

```
var arr = [ 1(0), 2(1), 3(2), 4(3), 5(4), 6(5), 7(6) ];
var newArr = arr.slice( 3, 6 );
console.log( 'slice',  newArr ); // [ 4, 5, 6 ]
```
