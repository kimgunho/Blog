---
emoji: ✍️
title: 면접을 위한 예상질문 자바스크립트편
date: '2021-12-15 15:00:00'
author: me
tags: interview FE javaScript
categories: 면접준비 JavaScript
---

# JavaScript 면접 질문사항 정리

## 1. Ajax란?

1999년 자바스크립트를 이용하여 **서버와 브라우저가 비동기**방식으로 데이터를 교환할 수 있는 통신기능인 Ajax(**A**synchronous **J**avascript **a**nd **X**ML)
서버로부터 코드를 전송받아 웹페이지 전체를 새롭게 랜더링할 필요없이 필요한 부분만 한정적으로 렌더링하는 방식

## 2. Node.js란?

기존 자바스크립트는 브라우저에서만 몇몇 액션만을 위한 언어로서 역할이었다.
하지만 Node가 2009년 나온 이후 많은 변화가 일어났다.
노드는 구글 V8 자바스크립트 엔진으로 빌드된 런타임 환경이다.
이는 브라우저 자바스크립트 엔진에서만 구동되는 이외의 환경에서도 동작할 수 있도록 엔진을 브라우저에서 독립시킨 실행환경이다.

## 3. SPA

현재의 웹 구조는 보다 많은 구조와 UX적인 환경을 제공하는것이 필수이며 이로인한 개발규모와 복잡도는 상승했다.
이에 좀더 수월하게 개발에 도움을 주기위한 많은 라이브러리와 프레임워크가 등장했다.
이러한 기준에 발맞춰 CBD(component based development) 방법론을 기반으로하는
SPA(single page application)가 대중화되면서 **Angular, React, Vue**등 다양한 프레임워크, 라이브러리가 탄생하였다.

**프레임워크와 라이브러리 개인기준 차이점**

- 프레임워크 : 해당 기능이 주로 이루어 개발이 이루어지는 프레임
- 라이브러리 : 내가 원하는 기능을 추출하여 사용할 수 있도록 복합적으로 돕는 프레임

## 함수형 프로그래밍, 순수함수, 비순수함수

### 함수형 프로그래밍

함수형 프로그래밍은 순수함수와 보조 함수의 조합을 통해 로직내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.

### 순수함수

함수형 프로그래밍에서 매개변수등만을 받고 그외에 외부적인 요인의 영향을 일절 받지않는 말그대로 순수한 함수라는 뜻이다.
순수함수는 동일한 인수가 전달되면 언제나 동일한 공식의 값을 반환한다.
**즉 어떤 외부 상태에도 의존하지않고 오직 전달되는 매개변수의 인수를 통한 공식의 반환값만을 가진다.**

```
let count = 0;

function add(n){
    return ++n
}

const = add(count);
console.log(count) // 1
// add함수는 매개변수만을 받으며 그외에는 영향이 가지않는다.
```

### 비순수함수

순수함수와 반대개념이며 외부상태에 따라 공식 반환값이 달라지는 함수이다.
즉 외부 상태에 의존하는 함수를 비순수 함수라고한다.

```
let count = 0;

function add(){
    return ++count; // 매개변수가 없으므로 외부상태 카운트값을 의존한다.
}

add();
console.log(count) // 1
add();
console.log(count) // 2
```

**비순수 함수는 외부 상태를 변경하므로 상태변화를 추적하기 어려워진다.**

## 스코프(유효범위)

- 스코프는 함수스코프, 변수 스코프와 관련이있다.
- 스코프는 es5의 var, es6의 let const와 각각 다르게 동작한다.(var를 지양한다.)
- 스코프는 전역스코프, 지역스코프로 구분할 수 있다.
- 쉽게 생각하면 말그대로 유효범위다.

  변수는 자신이 선언된 위치에 의하여 자신의 유효한 범위가 결정된다. 변수뿐만 아니라 모든 식별자도 같다.
  정리하면 **모든 식별자(변수, 함수, 클래스..)등 자신이 선언된 위치에 의해 다른코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다.**
  이를 우리는 **스코프**라고 한다. 즉 **식별자가 유효한 범위**를 말한다.

## OOP(객체지향 프로그래밍)

객체지향 프로그래밍은 여러개의 독립적인 인스턴스, 단위, 개체의 집합으로 표현하는 패러다임입니다.
잠시 객체지향 프로그래밍을 벗어나 이야기하자면
5년전 처음 코딩을 배우기 시작했던 시기에는 공감하지 못했지만 코드를 자주 접하고 다룰수록,
프로그래밍에 대한 깊이와 로직들간의 연결성, **이유없는 로직은 없다** 라는 심오하고도 깊은 철학적인 접근이 필요하다는것을 공감합니다.
이에 객체지향 프로그래밍이라는 패러다임도 그 시발점에서 나온것이라 알고있습니다.

좀더 쉬운 설명으로 예를 들면 회사, 사람, 모임등등 세상의 모든것들은 다양한 집합과 속성을 이루고 있습니다.
여기에 20살의 개발자로 일하는 홍길동씨가 있습니다.
그는

```
person = {
    name : '홍길동',
    age : '20',
    job : 'developer'
}
```

라는 객체속성을 가지고 있습니다. 이렇게 속성을 주체적으로 표현하면 특정한 사람과 다르게 구별할 수 있습니다.
이처럼 속성을 통하여 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체라 하며
객체지향 프로그래밍은 **독립적인 객체의 집합으로 프로그램을 표현하려는 패러다임**입니다.

### 객체지향 프로그래밍 키워드 5가지

1. 클래스 + 인스턴스 : 추상화를 거쳐 집단에 속하는 속성과 행위를 변수 또는 메서드에 정의하는 것
2. 추상화 : 목적만을 위하여 같은 특징을 지닌 집단의 추상화된 개념
3. 캡슐화 : 목적에 맞는 기능을 위하여 변수 혹은 메서드를 묶는 행위
4. 상속 : 상위 클래스의 기능에서 필요한 기능을 상속받거나 일부 커스텀이 필요한 기능도 가능하다. 코드의 중복성을 줄임
5. 다형성 : 상속받은 기능중 커스텀을 하여서 동작하는 과정에서 변수나 행위가 상위클래스와 다른 형태가 되거나 상황에 맞도록 다르게 구현될 수 있음을 말한다.

### 객체지향 프로그래밍의 장점과 단점

**장점**

- 비교적 나은 구조성과 상속으로 인하여 코드 재활용이 좋다.
- 이로 인하여 유지보수가 더 나아진다.
- 규모가 큰 대형프로젝트에 적합하다.

**단점**

- 처리속도가 비교적 느리다.
- 설계시 심도있는 접근이 필요하므로 시간과 노력이 필요

## this

this 에 관해 알아야 할 가장 중요한 특징은,
this 의 값은 this가 사용된 함수가 어떤 방식으로 "실행"되었는지에 따라 달라진다는 점이다.

일단 기본적으로 this는 window를 가르킨다.
기본 전역에서든 함수내에서든 this는 window이다.
그렇다면 우리는 this가 window가 아닌상황을 우선순위로 알아둘 필요가 있다.

### 객체안의 this

객체 안의 this는 객체 자신을 가르킨다.
여담으로 사실 전역에서 this를 호출하면 윈도우가 노출되는것도 window 객체이기 때문이다.
아래 코드를 보면

```
const test = {
    name : 'Lee ma',
    console.log(this) // test f
    console.log(this.name) // 'Lee ma'
}
```

위 객체는 this의 값이 test를 가르킨다.
중요한 개념중에 this는 **호출과 선언자를 잘 구분하여 생각하면 된다라는 것이다**

### 이벤트 핸들러의 this

이벤트 핸들러에서 this는 이벤트를 받는 HTML 요소를 가리킵니다.

```
const btn = document.querySelector('#btn')
btn.addEventListener('click', function () {
  console.log(this); //#btn
});
```

### 생성자 안에서 쓴 this

생성자 함수가 생성하는 객체로 this가 바인딩 됩니다.

```
function Person(name) {
  this.name = name;
}

var kim = new Person('kim');
var lee = new Person('lee');

console.log(kim.name); //kim
console.log(lee.name); //lee
```

### 화살표 함수의 this

화살표 함수의 경우에 this는 항상 상위 scope가 된다.

### 명시적 바인딩으로 this를 바꾸는 함수 메서드 삼총사 bind, call, apply

명시적 바인딩은 짝을 지어주는것이다. 아래 각 요소들을 확인해보자
**bind**
Bind는 함수를 호출하는 것이 아닌 this가 바인딩 된 새로운 함수를 리턴함

**call**
Call은 this를 바인딩하면서 함수를 호출하는 것, 두번째 인자를 apply와 다르게 하나씩 넘기는 것

**apply**
Apply는 this를 바인딩하면서 함수를 호출하는 것, 두번째인자가 배열

## 클로저

MDN에서는 클로저를 다음과 같이 정의하고 있다.
**클로저는 독립적인 (자유) 변수를 가리키는 함수이다. 또는, 클로저 안에 정의된 함수는 만들어진 환경을 ‘기억한다’.**
나만의 식대로 풀어보자면 클로저는 특정 목적을 위해 독립적인 변수를 반환하는 함수이다.
또한 클로저안에 정의된 행위는 그 환경을 기억한다.

### 클로저의 목적

- 함수안에서 함수를 생성할 시 대체로 진행된다.
- 특정 환경의 행위를 저장하여 행위를 반환한다.
- 클로저 외부스코프에서 내부로의 정보를 은닉화하여 접근제한을 할 수 있다.
- 목적은 아니지만 클로저의 행위가 끝나면 성능을 위하여 참조를 제거하는것이 좋다.

## 이벤트 위임

여러개의 하위 DOM요소에 각각 이벤트 핸들러를 등록하는 대신에 하나의 상위 DOM요소에 이벤트 핸들러를 등록하는 방법을 말한다.
만약 각각의 하위 요소 DOM의 존재에 이벤트핸들링을 준다면 성능적인 면에서도 유지보수면에서도 부적합한 코드일것이다.

## 비동기

자바스크립트는 기본적으로 동기식이다.(순차적인 프로세스)
이는 장점또한 있지만 만약 100개의 메일을 보내는 로직을 구현한다면
1개의 메일을 보내는데 1초가 걸린다하여도 100초라는 시간이 걸릴것이다.
이를 해결하기 위한 방법이 비동기(비순차적인 프로세스)이다.

즉 비동기처리방식은 실행중인 프로세스가 종료되지 않은 상태라 하여도 진행가능한 프로세스는 다같이 함께 진행할 수 있도록 실행하는 방식을 말한다.

동기를 비동기로 변경하는 대표 방식은 3가지 **콜백, 프로미스, 어씽크 어웨이**가 있으며 위에 정리는
[링크참조](/asynchronous/)

## REST API

REST 는 HTTP를 규정을 기반으로 클리이언트가 서버의 리소스를 접근하는 방식을 규정한 방안이고 REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.
**REST API의 설계원칙**

1. URI는 리소스를 표현해야한다.
   URI는 리소를 표현하는데 중점을 두어야한다. 식별할 수 있는 이름은 동사보다는 명사위주이다.

```
# bad
GET /getTodos/1

#good
GET /todos/1
```

2. 리소스의 대한 행위는 HTTP 요청 메소드로 표현한다.
   HTTP요청 메서드는 클라이언트가 서버에 주는 요청의 종류와 목적을 알리는 방법이다.
   주로 **5가지 요청 메서드**를 사용하여 CRUD(Create, Read, Update, Delete)를 구현한다.

- GET : 모든 or 특정 리소스 읽기
- POST : 리소스 생성
- PUT : 리소스 전체 수정
- PATCH : 리소스의 일부 수정
- DELETE : 모든 or 특정 리소스 제거
